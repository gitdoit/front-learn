// 声明两个联合类型 A B
type A = 1 | 2
type B = 2 | 3 | 4

// 对于C，我们去A和B的交叉类型（Intersection Types）
// 此时的行为就像是两个集合做交集
// 后记: 忘记什么[合集], 这里 & 的意思是既满足A又满足B
// 满足这种类型的 只有2了
type C = A & B  // => 2

// 对于D，我们取A和C的组合类型（Composing Types）
// 此时的行为就像是两个集合做并集， 结果显而易见
// 后记: 这里的意思是 或者满足A 或者满足B
// 满足这种类型的就是 1 2 3 4了,对吧, 因为1满足条件(或者满足A 或者满足B,因为1满足A) ,2 也是, 3也是,4也是, 5就不是了
type D = A | B // => 1 | 2 | 3 | 4

// 特殊情况1 
type E = false
type F = true 
// 你以为时 true | false
// 但得到的时 boolean， 其实也对
type G = E | F




/**
 * 对于对象类型？
 * 后记: 转变一下java的想法,ts中的类型不是那种 按照是否实现了同一个接口/类来判断这个实例是否是某种类型
 * TS里是[鸭子类型],长得像就行了
 * 
 */
type O1 = {
    a: string,
    b: string
}
type O2 = {
    a: string,
    c: string
}
// 按照直觉， 你以为 & 操作作用在这里还是求交集一样，得到结果 {c:string} ❌
// 其实实际效果像是求两个类型的并集，得到一个{a:string,b:string,c:string}

// 后记: 我悟了, type O3 = O1 & O2 的意思是 O3类型是一个既满足O1又满足O2的类型
// 那什么类型既满足O1又满足O2呢, 肯定是既有O1中所有的属性,又有O2中所有的属性了
// 结果看起来是将两个类型的属性做合集, 让人以为是在对类型中的属性 做 & 
type O3 = O1 & O2
let ins :O3 = {
    a: "",
    b: "",
    c: ""
}

// 既然上面的 & 最总结果是两个类型属性的 “合集”
// 那 | 操作应该就是“差集”了把 ❌
// 妈的,(type O4 = O1 | O2) | 在这里的意思是 O4 可以是 O1 也可以是O2
// 非常反直觉！！！
// 上面的 & 粒度 作用于到类型中属性，但是这里的 | 只作用到整个类型 🤷‍♂️
// 我真的服了



type O4 = O1 | O2
let ins1: O4 = {// 满足O1 👌
    a: "",
    b: ""
}
let ins2 :O4 = {// 满足O2 👌
    a: "",
    c: ""
}